import os
import sys
import json
from dorna2 import Dorna
import time
import subprocess
import argparse
import tracemalloc
import logging
import threading
import RPi.GPIO as GPIO
import math



ROBOT = Dorna()
TIMEOUT = 5   

c_axis = 0.04179

VERSION = "2.0.0"


# Represents the physical buttons and switches on the fixture. 
# Dictionary containing the input pin number and their active highs
PUMP_BTN = {"output": 0, "active_high": True}
RUN_SWITCH = {"input":1, "active_high":True}
MOTOR_SWITCH = {"input":2, "active_high":True}
HOME_BTN = {"input":3, "active_high":True}
EMERGENCY_BTN = {"input":6, "active_high":True}
TEMP_BTN = {"input":4, "active_high":False}




# Name of the position json file
POSITIONS_JSON = "positions.json"

# Available commands
HELP = "\nCommands: \n" \
    + " h/help                 : Print help\n" \
    + " q/quit                 : Quit program\n" \
    + " p/print                : Print positions.json\n" \
    + " m/motor                : Check motor switch\n"  \
    + " g/get                  : print current position data\n" \
    + "t/test                 : test position\n" \
    + "L/Lump                 : lump start\n"
# Functionality of each button and switch during editin mode
EDIT_HELP = "\n" \
    + "Emergency Stop          : Cancel Editing\n" \
    + "Run Switch              : Prints Dorna Arm positions\n" \
    + "Motor Switch            : Turns on Dorna Arm motor\n" \
    + "Home Button             : Homes Dorna Arm\n" \
    + "Run + Motor Switch      : Saves Dorna Arm positions\n" \



# Gets the current path to this python file
def get_position_path():
    current_directory = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(current_directory, POSITIONS_JSON)

def get_all_joint_positions():
    all_joints = ROBOT.get_all_joint()
    all_cart = ROBOT.get_all_pose()
    print("Joint: {} \n Cart: {}".format(all_joints, all_cart))
    return all_joints

# Trys to parse the position.json file in the current directory if
# file does not exist make a new file with predefined joints
def parse_positions_json():
    positions_json_path = get_position_path()
    try:
        with open(positions_json_path,  'r') as position_file:
            data = json.load(position_file)
            for key, value in data.items():
                data[key] = tuple(value)
            return data
    except FileNotFoundError:
        default_position_json = {
            "HOME":            (180.0, 180.0, -142.0, 135.0, 0.0, 0.0),
            "SAFE":            (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "DISPEN_BENEATH":  (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "DISPEN_GRAB":     (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "EJEC_ABOVE":      (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "EJEC_ATTACH":     (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "EJECT_WAIT":      (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "TRASH":           (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "TRASH_GENTLE1":   (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "TRASH_GENTLE2":   (90.0, -40.0, 130.0, 135.0, 0.0, 0.0),
            "test": (90.0, -40.0, 130.0, 135.0, 0.0, 10.0)
        }
        create_json(positions_json_path, default_position_json)
        return default_position_json

def clear_alarm(robot:Dorna):
    if robot.get_alarm():
        robot.set_alarm(0)
    print("alarm cleared")

def check_input(robot:Dorna, input_item:dict):
    input_index = input_item["input"]
    active_high = input_item["active_high"]
    # time.sleep(0.5)
    return robot.get_input(input_index) == active_high

def motor_switch(robot:Dorna):
    motor_status = check_input(robot, MOTOR_SWITCH)
    if motor_status:
        robot.set_motor(1)
    else:
        robot.set_motor(0)

# Sets the rail start position (Joint 6)
def homing_position(robot: Dorna):
    while check_input(robot, TEMP_BTN) == False:
        all_joints = ROBOT.get_all_joint()
        #print(all_joints)
        #print(check_input(robot, TEMP_BTN))
        
        robot.play(TIMEOUT = -1,
        cmd = "jmove",
        rel=0,
        j0= float(all_joints[0]),
        j1= float(all_joints[1]),
        j2= float(all_joints[2]),
        j3= float(all_joints[3]),
        j4= float(all_joints[4]),
        j5= float(all_joints[5]) - 0.25,
        vel=50.0, 
        accel=250.0, 
        jerk=5000.0
        )
    all_joints = ROBOT.get_all_joint()
    robot.play(TIMEOUT = -1,
        cmd = "jmove",
        rel=0,
        j0= float(all_joints[0]),
        j1= float(all_joints[1]),
        j2= float(all_joints[2]),
        j3= float(all_joints[3]),
        j4= float(all_joints[4]),
        j5= float(all_joints[5]) + 0.15,
        vel=10.0, 
        accel=10000.0, 
        jerk=20000.0
        )

    while check_input(robot, TEMP_BTN) == False:
        all_joints = ROBOT.get_all_joint()
        #print(all_joints)
        #print(check_input(robot, TEMP_BTN))
        
        robot.play(TIMEOUT = -1,
        cmd = "jmove",
        rel=0,
        j0= float(all_joints[0]),
        j1= float(all_joints[1]),
        j2= float(all_joints[2]),
        j3= float(all_joints[3]),
        j4= float(all_joints[4]),
        j5= float(all_joints[5]) - 0.02,
        vel=50.0, 
        accel=5000.0, 
        jerk=5000.0
        )
    print("position 5: {}".format(float(all_joints[5])))
    using_start_pos = get_all_joint_positions()
    zero = (-float(using_start_pos[5]))
    return(zero)

def pump_activate(robot: Dorna):
        print("This totes works yo")
        robot.set_output(0,1)
        time.sleep(5)
        robot.set_output(0,0)



def perimeter_wash(robot: Dorna, zero):
    using_pos1 = [90.152, 73.300, -121.871, 26.573, 0.000, 50.0]
    ready_cart =  [-0.786, 300.067, 268.442, -21.994, 0.0, 29.43, 0.0, 0.0]
    using_pos2 = [90.152, 73.300, -121.871, 26.573, 0.000, 16.0]
    width = [280.0, 300.0]
    height = [180.1, 200.0 ]
    Delta_Y = [(math.sin(22) * height[0]) , (math.sin(22) * height[1]) ]
    Delta_Z = [(math.cos(22) * height[0]), (math.cos(22) * height[1])]

    radius =50.8
    Delta_RY = math.sin(22) * radius
    Delta_RZ = math.cos(22) * radius
    

    Delta_move_side_y = [(height[0]+ 2 *radius) * math.sin(22), (height[1]+ 2 *radius) * math.sin(22)]
    Delta_move_side_z = [(height[0]+ 2 *radius) * math.cos(22), (height[1]+ 2 *radius) * math.cos(22)]

    robot.play(TIMEOUT = -1, 
        cmd = "jmove",
        rel=0, 
        x=ready_cart[0], 
        y=ready_cart[1], 
        z=ready_cart[2], 
        a=ready_cart[3], 
        b=ready_cart[4],
        c=ready_cart[5] - zero,
        vel=45, 
        accel=500, 
        jerk=1000
        )
    
    #Move to robot's leftmost screen
    robot.play(TIMEOUT = -1, 
        cmd = "jmove",
        rel=0, 
        j0=using_pos1[0], 
        j1=using_pos1[1], 
        j2=using_pos1[2], 
        j3=using_pos1[3], 
        j4=using_pos1[4],
        j5=using_pos1[5] - zero,
        vel=45, 
        accel=500, 
        jerk=1000
        )

    #Adjust leftside
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=Delta_RY, 
            z=-Delta_RZ, 
            a=0.0, 
            b=0.0,
            c=50.8 * c_axis,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=25, 
            z=0.0, 
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=-Delta_move_side_y[0],
            z=Delta_move_side_z[0],
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=0.0, 
            z=-0.0, 
            a=0.0, 
            b=0.0,
            c=-(width[0] + 2 * radius) * c_axis,
            vel=3.145, 
            accel=2000,
            jerk=4000
        )
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=Delta_move_side_y[0],
            z=-Delta_move_side_z[0],
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=0.0, 
            z=-0.0, 
            a=0.0, 
            b=0.0,
            c=(width[0] + 2 * radius) * c_axis,
            vel=3.145, 
            accel=2000,
            jerk=4000
        )
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=-25, 
            z=0.0, 
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )

def wash_single_screen(zero, screen):
    robot = ROBOT
    angle = math.radians(22)
    print("Angle: {}".format(angle))
    print(" Sin(22): {}".format(math.sin(angle)))
    width = [280.0, 300.0]
    height = [180.1, 200.0 ]
    segments = [12, 14]
    ready_cart =  [-0.786, 300.067, 268.442, -21.994, 0.0, 29.43, 0.0, 0.0]
    using_pos1 = [90.124, 57.357, -99.335, 19.980, 0.000, 50.0]
    using_pos2 = [90.124, 57.357, -99.335, 19.980, 0.000, 16.0]
    using_pos = [using_pos1, using_pos2]

    Delta_Y = [(math.sin(angle) * height[0]) , (math.sin(angle)* height[1]) ]
    Delta_Z = [(math.cos(angle) * height[0]), (math.cos(angle) * height[1])]
    Delta_C = [width[0] / segments[0] * .04179, width[1] / segments[1] * .04179]
    #Move to middle
    robot.play(TIMEOUT = -1, 
        cmd = "jmove",
        rel=0, 
        x=ready_cart[0], 
        y=ready_cart[1], 
        z=ready_cart[2], 
        a=ready_cart[3], 
        b=ready_cart[4],
        c=ready_cart[5] - zero,
        vel=15, 
        accel=2000, 
        jerk=4000
        )
   
    #Move to robot's leftmost screen
    robot.play(TIMEOUT = -1, 
        cmd = "jmove",
        rel=0, 
        j0=using_pos[screen][0], 
        j1=using_pos[screen][1], 
        j2=using_pos[screen][2], 
        j3=using_pos[screen][3], 
        j4=using_pos[screen][4],
        j5=using_pos[screen][5] - zero,
        vel=10, 
        accel=2000, 
        jerk=4000
        )
    for i in range(int(segments[screen]/2)):
        robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=-Delta_Y[screen], 
            z=-Delta_Z[screen], 
            a=0.0, 
            b=180.0,
            c=-Delta_C[screen],
            vel=250, 
            accel=2000, 
            jerk=4000
        )
        robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=Delta_Y[screen], 
            z=Delta_Z[screen], 
            a=0.0, 
            b=-180.0,
            c=-Delta_C[screen],
            vel=250, 
            accel=2000, 
            jerk=4000
            )

def wash_single_perimeter(zero, screen):
    robot = ROBOT
    angle = math.radians(22)
    depthY = 25
    radius =101.6
    using_pos1 = [90.124, 57.357, -99.335, 19.980, 0.000, 50.0]
    using_pos2 = [90.124, 57.357, -99.335, 19.980, 0.000, 16.0]
    ready_cart =  [-0.786, 300.067, 268.442, -21.994, 0.0, 29.43, 0.0, 0.0]
    using_pos = [using_pos1, using_pos2]
    width = [280.0, 300.0]
    height = [180.1, 200.0 ]
    Delta_Y = [(math.sin(angle) * height[0]) , (math.sin(angle) * height[1]) ]
    Delta_Z = [(math.cos(angle) * height[0]), (math.cos(angle) * height[1])]
    print("Delta_Y: {}".format(Delta_Y))
    print("Delta_Z: {}".format(Delta_Z))

    Delta_RY = math.sin(angle) * radius
    Delta_RZ = math.cos(angle) * radius
    

    Delta_move_side_y = [(height[0]+ 2 *radius) * math.sin(angle), (height[1]+ 2 *radius) * math.sin(angle)]
    Delta_move_side_z = [(height[0]+ 2 *radius) * math.cos(angle), (height[1]+ 2 *radius) * math.cos(angle)]

    #Move to robot's specified screen
    robot.play(TIMEOUT = -1, 
        cmd = "jmove",
        rel=0, 
        j0=using_pos[screen][0], 
        j1=using_pos[screen][1], 
        j2=using_pos[screen][2], 
        j3=using_pos[screen][3], 
        j4=using_pos[screen][4],
        j5=using_pos[screen][5] - zero,
        vel=45, 
        accel=500, 
        jerk=1000
        )

    #Adjust leftside
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=Delta_RY, 
            z=Delta_RZ, 
            a=0.0, 
            b=0.0,
            c=radius * c_axis,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=depthY, 
            z=0.0, 
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    # Moves down left side screen
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=-Delta_move_side_y[screen],
            z=-Delta_move_side_z[screen],
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    # Moves across the bottom side
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=0.0, 
            z=-0.0, 
            a=0.0, 
            b=0.0,
            c=-(width[screen] + 2 * radius) * c_axis,
            vel=3.145, 
            accel=2000,
            jerk=4000
        )
    # Move up right side of screen
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=Delta_move_side_y[screen],
            z=Delta_move_side_z[screen],
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )
    # Move across the top of the screen
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=0.0, 
            z=-0.0, 
            a=0.0, 
            b=0.0,
            c=(width[screen] + 2 * radius) * c_axis,
            vel=3.145, 
            accel=2000,
            jerk=4000
        )
    # Move away from screen
    robot.play(TIMEOUT = -1, 
            cmd = "lmove",
            rel=1, 
            x=0.0, 
            y=-2 * depthY, 
            z=0.0, 
            a=0.0, 
            b=0.0,
            c=0.0,
            vel=75, 
            accel=2000, 
            jerk=4000
        )


def test_position(robot: Dorna):
    all_joints = ROBOT.get_all_joint()
    robot.play(TIMEOUT = -1,
        cmd = "jmove",
        rel=0,
        j0= float(all_joints[0]),
        j1= float(all_joints[1]),
        j2= float(all_joints[2]),
        j3= float(all_joints[3]),
        j4= float(all_joints[4]),
        j5= float(all_joints[5]) - 5,
        vel=25.0, 
        accel=15000.0, 
        jerk=5000.0
        )
        
def start_position(robot: Dorna, revs):
    zero = homing_position(robot)
    using_pos2 = [90.180, 97.209, -125.076, 5.872, 0.000, 25.252]
    #Move ready position to json file later

    # Begin washing motion process
    for i in range(revs):
     double_wash(robot, zero)
     print(i + 1)

def loop():
    while True:
        GPIO.setup(9, GPIO.IN)
        print(str(GPIO.input(9)))

def accguy(revs):
    counter = 0
    robot = ROBOT
    ready_cart =  [-0.786, 300.067, 268.442, -21.994, 0.0, 29.43, 0.0, 0.0]

    zero = homing_position(ROBOT)
    
    for i in range(2 * revs):
        robot.play(TIMEOUT = -1, 
            cmd = "jmove",
            rel=0, 
            x=ready_cart[0], 
            y=ready_cart[1], 
            z=ready_cart[2], 
            a=ready_cart[3], 
            b=ready_cart[4],
            c=ready_cart[5] - zero,
            vel=45, 
            accel=2000, 
            jerk=4000
        )
        
        wash_single_screen(zero, counter)
        wash_single_perimeter(zero, counter)
        print("Cleaned screen {} {} times".format(str(counter), str(int(i / 2)+1)))
        print("")
        if counter == 0:
            counter = 1
        else:
            counter = 0
    robot.play(TIMEOUT = -1, 
        cmd = "jmove",
        rel=0, 
        x=ready_cart[0], 
        y=ready_cart[1], 
        z=ready_cart[2], 
        a=ready_cart[3], 
        b=ready_cart[4],
        c=ready_cart[5] - zero,
        vel=15, 
        accel=2000, 
        jerk=4000
    )


def main():
    pid = os.getpid()
    try:
        print("Connected") if ROBOT.connect() else sys.exit()
        #help()
        while True:
            command = input("> ")
            if command in ['q', 'quit']:
                break
            elif command in ['m', 'motor']:
                motor_switch(ROBOT)
            elif command in ['g', 'get']:
                get_all_joint_positions()
            elif command in ['h', 'homing']:
                homing_position(ROBOT)
            elif command in ['s', 'start']:
                start_position(ROBOT, 10)
            elif command in ['L', 'Lump']:
                pump_activate(ROBOT)
            elif command in ['t', 'test']:
                accguy(2)
            elif command in ['c','clear']:
                clear_alarm(ROBOT)
            else:
                help()
    except Exception as e:
        print(e)
    finally:
        motor_switch(ROBOT)
        print("Disconnected")
        ROBOT.close(ROBOT)






if __name__ == "__main__":
    print(f"Version: {VERSION}")
    main()
